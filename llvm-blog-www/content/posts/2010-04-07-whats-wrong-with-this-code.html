---
author: Daniel Dunbar
blogger_id: tag:blogger.com,1999:blog-6088150582281556517.post-3794498154199620838
blogger_orig_url: http://blog.llvm.org/2010/04/whats-wrong-with-this-code.html
date: "2010-04-07T11:49:00Z"
modified_time: "2010-04-07T13:01:34.681-07:00"
tags: ["KLEE"]
title: What's wrong with this code?
---

A user on IRC sent me this interesting KLEE example today, which I thought was cute enough I should post it.<br /><br /><div>If you aren't familiar with it, <a href="http://klee.llvm.org/">KLEE</a> is a tool for symbolic execution of LLVM code. It is way too complicated to explain here, but for the purposes of this example all you need to know is that it tries to explore all possible paths through a program.</div><div><br /><br /><a name='more'></a><br /><br /><br /></div><div>In this case, the user was actually talking to me because he thought there was a bug in KLEE, because it was only finding one path through the code. Here is the example:</div><div><pre>$ cat t.c<br />#include "klee/klee.h"<br /><br />int f0(int x) {<br />if (x * x == 1000)<br />return 1;<br />else<br />return 0;<br />}<br /><br />int main() {<br />return f0(klee_int("x"));<br />}<br /></pre>The idea here is that <tt>klee_int("x")</tt> creates a new symbolic variable, which can be <i>anything</i> (well, any possible <tt>int</tt>).</div><div><br /></div><div>The user was expecting that there would be two possible paths through this program, one returning 1 and one returning 0. But KLEE only finds one:</div><div><pre>$ clang -I ~/public/klee/include -flto -c t.c<br />$ ~/public/klee.obj.64/Debug/bin/klee t.o<br />KLEE: output directory = "klee-out-5"<br /><br />KLEE: done: total instructions = 24<br />KLEE: done: completed paths = 1<br />KLEE: done: generated tests = 1</pre><br /></div><div>Upon showing the example to me, I was also confused for a moment. However, since I happen to trust KLEE, I knew to look for a problem in the test case! And of course, the square root of 1000 isn't an integer, so there is no way this code can return 1. If we change the 1000 to 100, KLEE finds two paths as we would expect:</div><div><pre>$ cat t.c<br />#include "klee/klee.h"<br /><br />int f0(int x) {<br />if (x * x == 100)<br />return 1;<br />else<br />return 0;<br />}<br /><br />int main() {<br />return f0(klee_int("x"));<br />}<br />$ clang -I ~/public/klee/include -flto -c t.c<br />$ ~/public/klee.obj.64/Debug/bin/klee t.o<br />KLEE: output directory = "klee-out-6"<br /><br />KLEE: done: total instructions = 31<br />KLEE: done: completed paths = 2<br />KLEE: done: generated tests = 2</pre><br /></div>This example shows exactly what KLEE was designed for -- reasoning about code (or math) is hard, and it is great to let a machine do it for you!
