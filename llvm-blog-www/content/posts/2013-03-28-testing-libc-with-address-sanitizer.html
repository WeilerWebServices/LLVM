---
author: Marshall Clow
blogger_id: tag:blogger.com,1999:blog-6088150582281556517.post-2344257603365985024
blogger_orig_url: http://blog.llvm.org/2013/03/testing-libc-with-address-sanitizer.html
date: "2013-03-28T14:02:00Z"
modified_time: "2013-04-01T10:09:17.862-07:00"
tags: ["sanitizer","C++","Clang"]
title: Testing libc++ with Address Sanitizer
---

<i>[This article is re-posted in a slightly expanded form <a href="http://cplusplusmusings.wordpress.com/2013/03/20/testing-libc-with-address-sanitizer/">from Marshall's blog</a>]</i><br />I've been running the libc++ tests off and on for a while. It's a quite extensive test suite, but I wondered if there were any bugs that the test suite was not uncovering. In the upcoming clang 3.3, there is a new feature named <a href="http://clang.llvm.org/docs/AddressSanitizer.html">Address Sanitizer</a> which inserts a bunch of runtime checks into your executable to see if there are any "out of bounds" reads and writes to memory.<br />In the back of my head, I've always thought that it would be nice to be able to say that libc++ was "ASan clean" (i.e, passed all of the test suite when running with Address Sanitizer).<br />So I decided to do that.<br /><br /><a name='more'></a> [ All of this work was done on Mac OS X 10.8.2/3 ]  <h3> How to run the tests:</h3>There's a script for running the tests. It's called <code>testit</code>.<br /><pre><code>    $ cd $LLVM/libcxx/test ; ./testit<br /></code></pre><pre><code><br /></code></pre>where $LLVM/libcxx is where libc++ is checked out.  This takes about 30 minutes to run.  Without Address Sanitizer, libc++ fails 12 out of the 4348 tests on my system.  <h3>Running the tests with Address Sanitizer</h3><pre><code>    $ cd $LLVM/libcxx/test ; CC=/path/to/tot/clang++ OPTIONS= "-std=c++11 -stdlib=libc++ -fsanitize=address" ./testit<br /></code></pre><em>Note: the default options are "-std=c++11 -stdlib=libc++", that's what you get if you don't specify anything</em>.This takes about 92 minutes; just a bit more than three times as long. With Address Sanitizer, libc++ fails 54 tests (again, out of 4348)<br /><br />What are the failures?<br /><br /><ul><li>In 11 tests, Address Sanitizer detected a one-byte write outside a heap block. All of these involve iostreams. I created a small test program that ASan also fires on, and sent it to Howard Hinnant (who wrote most of libc++), and he found a place where he was allocating a zero-byte buffer by mistake. One bug, multiple failures. He fixed this in revision <a href="http://llvm.org/viewvc/llvm-project?rev=177452&amp;view=rev">177452</a>.</li><li>2 tests for std::random were failing. This turned out to be an off-by-one error in the test code, not in libc++. I fixed these in revisions <a href="http://llvm.org/viewvc/llvm-project?rev=177355&amp;view=rev">177355</a> and <a href="http://llvm.org/viewvc/llvm-project?rev=177464&amp;view=rev">177464</a>.</li><li>Address Sanitizer detected memory allocations failing in 4 cases. This is expected, since some of the tests are testing the memory allocation system of libc++. However, it appears that ASan does not call the user-supplied <code>new_handler</code> when memory allocation fails (and may not throw <code>std::bad_alloc</code>, ether). I have filed <a href="http://llvm.org/bugs/show_bug.cgi?id=15544">PR15544</a> to track this issue.</li><li>25 cases are failing where the program is failing to load, due to a missing symbol. This is most commonly <code>std::__1::__get_sp_mut(void const *)</code>, but there are a couple others. Howard says that this was added to libc++ after 10.8 shipped, so it's not in the dylib in /usr/lib. If the tests are run with a copy of libc++ built from source, they pass.</li><li>There are the 12 cases that were failing before enabling Address Sanitizer.</li></ul>Once Howard and I fixed the random tests and the bug in the iostreams code, I re-ran the tests using a recently build libc++.dylib.<br /><pre><code>    $ cd $LLVM/libcxx/test ; DYLD_LIBRARY_PATH=$LLVM/libcxx/lib CC=/path/to/tot/clang++ OPTIONS= "-std=c++11 -stdlib=libc++ -fsanitize=address" ./testit<br /></code></pre>This gave us 16 failures: <br /><ul><li>The 4 failures that have to do with memory allocation failures.</li><li>The 12 failures that we started with.</li></ul><br /><h4>Conclusion</h4>I'm glad to see that there were so few problems in the libc++ code. It's a fundamental building block for applications on Mac OS X (and, as llvm becomes more popular, other systems). And now it's better than it was when we started this exercise.However, we did find a couple bugs in the test suite, and one heap-smashing bug in libc++. We also found a limitation in Address Sanitizer, too - which the developers are working on addressing.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
