---
author: Issam
blogger_id: tag:blogger.com,1999:blog-6088150582281556517.post-2458251717979760519
blogger_orig_url: http://blog.llvm.org/2013/04/static-analysis-tools-using-clang-in.html
date: "2013-04-15T03:39:00Z"
modified_time: "2013-04-15T07:14:20.581-07:00"
tags: ["Clang","Products"]
thumbnail: http://4.bp.blogspot.com/-WDcl2mtJ8Do/UWnL-S-FgiI/AAAAAAAAAn0/3LTWx4a32XY/s72-c/clang.gif
title: 'Static analysis tools: using Clang in CppDepend'
---

<div dir="ltr" style="text-align: left;" trbidi="on"><br />Static analysis is a method of computer program debugging that is done by examining the code without executing the program. The process provides an understanding of the code structure, can help to ensure that the code adheres to industry standards, and can find bugs not easy to detect.<br /><br />To develop a C / C++ static analysis tool, a parser is needed to parse the source code. C++ is a very powerful language but its syntax is a little bit complicated, what makes the parser not easy to develop.<br /><br />When we began the development of <a href="http://www.cppdepend.com/">CppDepend </a>about four years ago we needed a reliable C / C++ parser. &nbsp;At that time, Clang was an option but was not widely used and we didn’t know if it would ultimately develop into a fully-featured compiler frontend.<br /><br />Last year, for the&nbsp;major release of CppDepend 3.0,&nbsp;we re-evaluated our C / C++ parser with a goal of getting more reliable results. &nbsp;We checked Clang to see where its evolution went and were very surprised that it now implements virtually all C++'11 features and became very popular. &nbsp;Clang now provide solid infrastructure to write tools that need syntactic and semantic information about a program.<br /><br /><a name='more'></a><br /><br />Clang is designed to be modular, and like other compilers it has three phases: <br /><ul style="text-align: left;"><li>The front end that parses source code, checking it for errors, and builds a language-specific Abstract Syntax Tree (AST) to represent the input code.</li><li>The optimizer: its goal is to do some optimization on the AST generated by the front end.</li><li>The back end: generates the final code to be executed by the machine, it depends of the target architecture.</li></ul><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-WDcl2mtJ8Do/UWnL-S-FgiI/AAAAAAAAAn0/3LTWx4a32XY/s1600/clang.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-WDcl2mtJ8Do/UWnL-S-FgiI/AAAAAAAAAn0/3LTWx4a32XY/s1600/clang.gif" /></a></div><br /><br />In our case we needed only to use the front end parser, and we use the generated AST. For that we added our custom&nbsp;ASTFrontEndAction.<br />Each ASTFrontEndAction create one or many ASTConsumer as shown by the following dependency gaph:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-Fvq7jfoaiwY/UWnTLIOexFI/AAAAAAAAAoE/86hDIkA9OaQ/s1600/clang2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-Fvq7jfoaiwY/UWnTLIOexFI/AAAAAAAAAoE/86hDIkA9OaQ/s1600/clang2.png" /></a></div><br /><br />ASTConsumer is an abstract class, and we have to implement our AST consumer for our specific needs. And to do that we had take a look at the implementation of the existing AST Consumers to understand how they works, and here are all the classes inheriting from ASTConsumer:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-3I8Luf_nK8Y/UWnVKzU3ooI/AAAAAAAAAoQ/aBd4RBORAjM/s1600/clang3.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-3I8Luf_nK8Y/UWnVKzU3ooI/AAAAAAAAAoQ/aBd4RBORAjM/s1600/clang3.png" /></a></div><br />And we took &nbsp;ASTPrinter and ASTDumpXML as examples to understand how to implements our specific AST consumer.<br /><br />&nbsp;Thanks to all the developers behind LLVM and Clang for their big efforts to deliver a powerful compiler, and to thank all open source C / C++ contributors, we are giving you a CppDepend "Pro license" for free. &nbsp;CppDepend can be used to analyze a code base in order to:<br /><br />•<span class="Apple-tab-span" style="white-space: pre;"> </span>Improve the code base quality.<br />•<span class="Apple-tab-span" style="white-space: pre;"> </span>Help new contributors to understand the existing code base.<br />•<span class="Apple-tab-span" style="white-space: pre;"> </span>Automate the code review to be sure that all the coding rules specified by the manager are satisfied.<br />•<span class="Apple-tab-span" style="white-space: pre;"> </span>Generate custom reports for documentation purpose.<br /><br />To get your CppDepend Pro license, you can just send us a mail at support@cppdepend.com with the following infos:<br /><br />•<span class="Apple-tab-span" style="white-space: pre;"> </span>Name of the contributor.<br />•<span class="Apple-tab-span" style="white-space: pre;"> </span>Link to the patches that you have contributed.<br /><br />Thanks!</div>
