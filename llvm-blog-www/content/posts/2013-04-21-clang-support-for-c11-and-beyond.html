---
author: Richard Smith
blogger_id: tag:blogger.com,1999:blog-6088150582281556517.post-2790056591995646763
blogger_orig_url: http://blog.llvm.org/2013/04/clang-support-for-c11-and-beyond.html
date: "2013-04-21T07:04:00Z"
modified_time: "2013-04-21T07:04:35.763-07:00"
tags: ["C++","new-in-llvm-3.3","Clang"]
title: Clang support for C++11 and beyond
---

As of <a href="http://llvm.org/viewvc/llvm-project?view=revision&amp;revision=179861">r179861</a>, Clang implements the <b>entirety</b> of the C++11 language standard. The following features have been implemented since the release of Clang 3.2, along with our plans for "C++1y".<br /><br /><a name='more'></a><br /><h3>Support for <tt>[[attributes]]</tt></h3>C++11's <tt>[[attribute]]</tt> syntax is now fully supported, including support for the standard <tt>[[noreturn]]</tt> and <tt>[[carries_dependency]]</tt> attributes (although <tt>[[carries_dependency]]</tt> does not provide improved code generation). This allows non-returning functions to be written with a standard syntax:  <br /><br /><pre>[[noreturn]] void foo() {<br />  while (true) do_something();<br />}<br /></pre><pre></pre><br />Just like <tt>__attribute__((noreturn))</tt>, Clang will warn you if you use this attribute on a function which can return, and will optimize callers on the assumption that the function does not return. Unlike <tt>__attribute__((noreturn))</tt>, <tt>[[noreturn]]</tt> is never part of a function's type. <br /><br />As with g++'s implementation, <tt>__attribute__((foo))</tt> attributes which are supported by g++ can be written as <tt>[[gnu::foo]]</tt>. Clang-specific <tt>__attribute__((...))</tt>s are not available through this syntax (patches to add <tt>[[clang::...]]</tt> attribute names are welcome).<br /><br />Clang also now provides complete support for C++11's almost-attribute <tt>alignas(...)</tt>.  <br /><h3>Inheriting constructors</h3>Clang now supports C++11's inheriting constructor syntax, which provides a simple mechanism to re-export all the constructors from a base class, other than default constructors, or constructors which would be copy or move constructors for either the base or derived class. Example:  <br /><br /><pre>struct Base {<br />  Base(); // default constructor, not inherited<br />  Base(int, char);<br />  template&lt;typename T&gt; Base(T &amp;x);<br />};<br />struct Derived : Base {<br />  using Base::Base;<br />};<br />Derived f(1, 'x');<br />Derived d("foo"); // ok, calls inheriting constructor template<br /></pre><h3><tt>thread_local</tt> variables</h3>Clang now supports C++11's <tt>thread_local</tt> keyword, including dynamic initialization and destruction of thread-local objects. Dynamic destruction requires a C++ runtime library which provides <tt>__cxa_thread_atexit</tt>, which is currently only provided by the g++4.8 C++ runtime library.  <br /><h2>C++1y</h2>With C++11 out of the door, what's next? The C++ standardization committee voted yesterday to create the first Committee Draft for C++1y (which will very likely be C++14). Since this is only the first draft, there will probably be many minor changes before C++1y is done, but the rough feature set is unlikely to change much. This new language standard includes:  <br /><ul><li>Generalized lambdas, allowing a templated call operator and arbitrary captures: <br /><br /><pre>auto apply = [v(21)] (auto &amp;&amp;fn) { fn(v); };<br />apply([] (int &amp;n) { n += 21; });<br />apply([] (int n) { std::cout &lt;&lt; n; });<br /><br /></pre></li><li>Return type deduction for (non-lambda) functions: <br /><br /><pre>auto fn(int n) { return something(n); }<br /><br /></pre></li><li>A more powerful <tt>constexpr</tt> feature, allowing variable mutation and loops: <br /><br /><pre></pre><pre>constexpr auto len(const char *str) {<br />  int k = 0;<br />  while (*str++) ++k;<br />  return k;<br />}<br />static_assert(len("foo") == 3, "hooray");<br /></pre></li></ul>The improved <tt>constexpr</tt> feature comes with a backwards-compatibility cost, however. In order to support variable mutation for user-defined types, those types need to have <tt>constexpr</tt> member functions which are not <tt>const</tt>, so the C++11 rule which made <tt>constexpr</tt> member functions implicitly <tt>const</tt> has been removed. This means that you will need to make the <tt>const</tt> explicit if you were previously relying on this shorthand. Rewrite: <br /><br /><pre></pre><pre>struct S {<br />  int n;<br />  constexpr int get() { return n; }<br />};<br /></pre><br />... as ... <br /><pre></pre><pre>struct S {<br />  int n;<br />  constexpr int get() const { return n; }<br />};<br /></pre><br />... and your code will work in both C++11 and C++14. Clang already has a warning for code which is relying on the implicit <tt>const</tt> rule, and will fix it for you if you run <tt>clang -fixit</tt>. Other compilers supporting C++11 <tt>constexpr</tt>&nbsp;are expected to start providing similar warnings soon. <br /><br />Several of the new features were prototyped in Clang prior to standardization, and we expect implementations of those to land in Clang SVN over the coming weeks. See the <a href="http://clang.llvm.org/cxx_status.html">Clang C++ status page</a> for the latest details on C++1y features and Clang's support for them. The implemented features can be enabled with the <tt>-std=c++1y</tt> command-line flag. <br /><br />If you find bugs in the C++11 support, please report them on <a href="http://llvm.org/bugs">our bug tracker</a>. If you want to get involved fixing bugs or working on C++1y support, <a href="http://clang.llvm.org/get_involved.html">our website</a> has details of how you can help.
