---
author: Hans Wennborg
blogger_id: tag:blogger.com,1999:blog-6088150582281556517.post-1581884294113769990
blogger_orig_url: http://blog.llvm.org/2013/11/the-clang-cl-fallback-mode.html
date: "2013-11-05T08:42:00Z"
modified_time: "2013-11-05T08:42:07.038-08:00"
title: The clang-cl /fallback mode
---

<p>There has been a lot of work lately towards bringing an LLVM toolchain to the Windows platform (see <a href="http://blog.llvm.org/2013/09/a-path-forward-for-llvm-toolchain-on.html">A path forward for an LLVM toolchain on Windows</a>). One result of that work is a new driver mode for Clang: <a href="http://clang.llvm.org/docs/UsersManual.html#clang-cl">clang-cl</a>. This mode makes Clang understand the same kind of command-line arguments as Visual Studio's compiler, cl.exe. For example, a typical command to compile a file into an executable with Clang might be "clang hello.cc -o hello", whereas with cl.exe, one would use "cl.exe hello.cc /Fehello". Now one can use the latter syntax with Clang by substituting "cl.exe" with "clang-cl". This makes it easy to use Clang for existing projects in Visual Studio.</p> <p>For the most part, clang-cl accepts exactly the same arguments as cl.exe. However, it also accepts some Clang-specific options. One such option that was added recently is <a href="http://clang.llvm.org/docs/UsersManual.html#the-fallback-option">the /fallback flag</a>. The purpose of this flag is to make it easy to use clang-cl even in projects where Clang cannot yet compile all of the code. This post gives an example of how /fallback can be used.</p> <a name='more'></a> <p>The way clang-cl works in /fallback mode is that it first tries to compile the code with Clang, and if that fails for some reason it falls back to compiling with cl.exe. Consider the following two files, where main.cpp can be compiled by Clang, but printer.cpp cannot:</p> <pre style="text-indent: 0px;"><br />printer.cpp:<br /><br />#include &lt;iostream&gt;<br />void print_hello(const char *s) {<br />  std::cout &lt;&lt; "Hello from " &lt;&lt; s &lt;&lt; "!" &lt;&lt; std::endl;<br />}<br /></pre> <pre style="text-indent: 0px;"><br />main.cpp:<br /><br />extern void print_hello(const char*);<br />int main(int argc, char **argv) {<br />  print_hello(argv[0]);<br />  return 0;<br />}<br /></pre> <p>clang-cl cannot compile printer.cpp since it includes iostream which uses language features that are not completely supported yet (hopefully they will be soon). However, clang-cl can still compile the two files in fallback mode:</p> <pre style="text-indent: 0px;">clang-cl /fallback /Fehello main.cpp printer.cpp</pre> <p>Clang will compile main.cpp successfully, print some error messages about the features it does not support for printer.cpp, and fall back to the cl.exe compiler for that file. The compiled files will be linked together into hello.exe.</p> <p>Note that this is not fool proof: even if clang-cl thinks it has compiled a file successfully, there can be bugs in the generated code that cause failures at link- or run-time.</p> <p>Currently, the fallback mode will cause clang-cl to fall back on any kind of error. Going forward, it will be changed to only fall back on certain kinds of internal errors, and as Clang's Windows support improves, the fallback mode will eventually become unnecessary and removed. It is still early days for clang-cl, but you can try it out for yourself by downloading the toolchain from the <a href="http://llvm.org/builds/">LLVM Snapshot Builds website</a>.</p>
