---
author: Hans Wennborg
blogger_id: tag:blogger.com,1999:blog-6088150582281556517.post-5922508928131259990
blogger_orig_url: http://blog.llvm.org/2018/11/30-faster-windows-builds-with-clang-cl_14.html
date: "2018-11-14T04:49:00Z"
modified_time: "2018-11-14T04:49:52.465-08:00"
tags: ["Windows","clang-cl"]
title: 30% faster Windows builds with clang-cl and the new /Zc:dllexportInlines- flag
url: "2018/11/30-faster-windows-builds-with-clang-cl_14.html"
---

<h2>Background</h2> <p>In the course of adding Microsoft Visual C++ (MSVC) compatible Windows support to Clang, we worked hard to make sure the <a href="https://docs.microsoft.com/en-us/cpp/cpp/dllexport-dllimport?view=vs-2017">dllexport and dllimport declspecs</a> are handled the same way by Clang as by MSVC.</p> <p>dllexport and dllimport are used to specify what functions and variables should be externally accessible ("exported") from the currently compiled Dynamic-Link Library (DLL), or should be accessed ("imported") from another DLL. In the class declaration below, <code>S::foo()</code> will be exported when building a DLL:</p> <pre style="text-indent:0"><br />struct __declspec(dllexport) S {<br />  void foo() {}<br />};<br /></pre> <p>and code using that DLL would typically see a declaration like this:</p> <pre style="text-indent:0"><br />struct __declspec(dllimport) S {<br />  void foo() {}<br />};<br /></pre> <p>to indicate that the function is defined in and should be accessed from another DLL.</p> <p>Often the same declaration is used along with a <a href="https://chromium.googlesource.com/chromium/src/+/72.0.3608.5/base/base_export.h">preprocessor macro</a> to flip between dllexport and dllimport, depending on whether a DLL is being built or consumed.</p> <p>The basic idea of dllexport and dllimport is simple, but the semantics get more complicated as they interact with more facets of the C++ language: templates, inheritance, different kinds of instantiation, redeclarations with different declspecs, and so on. Sometimes the semantics are surprising, but by now we think clang-cl gets most of them right. And as the old maxim goes, once you know the rules well, you can start tactfully breaking them.</p> <p>One issue with dllexport is that for inline functions such as <code>S::foo()</code> above, the compiler must emit the definition <em>even if it's not used in the translation unit</em>. That's because the DLL must export it, and the compiler cannot know if any other translation unit will provide a definition.</p> <p>This is very inefficient. A dllexported class with inline members in a header file will cause definitions of those members to be emitted in <em>every translation unit that includes the header</em>, directly or indirectly. And as we know, C++ source files often end up including a lot of headers. This behaviour is also different from non-Windows systems, where inline function definitions are not emitted unless they're used, even in shared objects and dynamic libraries.</p>  <h2>/Zc:dllexportInlines-</h2> <p>To address this problem, clang-cl recently gained a new command-line flag, <a href="https://clang.llvm.org/docs/UsersManual.html#the-zc-dllexportinlines-option">/Zc:dllexportInlines-</a> (MSVC uses the /Zc: prefix for <a href="https://docs.microsoft.com/en-us/cpp/build/reference/zc-conformance?view=vs-2017">language conformance options</a>). The basic idea is simple: since the definition of an inline function is available along with its declaration, it's not necessary to import or export it from a DLL &mdash; the inline definition can be used directly. The effect of the flag is to not apply class-level dllexport/dllimport declspecs to inline member functions. In the two examples above, it means <code>S::foo()</code> would not be dllexported or dllimported, even though the <code>S</code> class is declared as such.</p> <p>This is very similar to the <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html#index-fvisibility-inlines-hidden">-fvisibility-inlines-hidden</a> Clang and GCC flag used on non-Windows. For C++ projects with many inline functions, it can significantly reduce the set of exported functions, and thereby the symbol table and file size of the shared object or dynamic library, as well as program load time.</p> <p>On Windows however, the main benefit is not having to emit the unused inline function definitions. This means the compiler has to do much less work, and reduces object file size which in turn reduces the work for the linker. For Chrome, we <a href="https://groups.google.com/a/chromium.org/d/msg/chromium-dev/xYVt4PFeObA/tc7CE3ojBgAJ">saw 30&nbsp;% faster full builds</a>, 30&nbsp;% shorter link times for blink_core.dll, and 40&nbsp;% smaller total .obj file size.</p> <p>The reduction in .obj file size, combined with the enormous reduction in .lib files allowed by previously switching linkers to lld-link which uses thin archives, means that a typical Chrome build directory is now 60&nbsp;% smaller than it would have been just a year ago.</p> <p>(Some of the same benefit can be had without this flag if the dllexport inline function comes from a pre-compiled header (PCH) file. In that case, the definition will be emitted in the object file when building the PCH, and so is not emitted elsewhere unless it's used.)</p> <h2>Compatibility</h2> <p>Using /Zc:dllexportInlines- is "half ABI incompatible". If it's used to build a DLL, inline members will no longer be exported, so any code using the DLL must use the same flag to not dllimport those members. However, the reverse scenario generally works: a DLL compiled without the flag (such as a system DLL built with MSVC) can be referenced from code that uses the flag, meaning that the referencing code will use the inline definitions instead of importing them from the DLL.</p> <p>Like -fvisibility-inlines-hidden, /Zc:dllexportInlines- breaks the C++ language guarantee that (even an inline) function has a unique address within the program. When using these flags, an inline function will have a different address when used inside the library and outside.</p> <p>Also, these flags can lead to link errors when inline functions, which would normally be dllimported, refer to internal symbols of a DLL:</p> <pre style="text-indent:0"><br />void internal();<br /><br />struct __declspec(dllimport) S {<br />  void foo() { internal(); }<br />}<br /></pre> <p>Normally, references to <code>S::foo()</code> would use the definition in the DLL, which also contains the definition of <code>internal()</code>, but when using /Zc:dllexportInlines-, the inline definition of <code>S::foo()</code> is used directly, resulting in a link error since no definition of <code>internal()</code> can be found.</p> <p>Even worse, if there is an inline definition of <code>internal()</code> containing a static local variable, the program will now refer to a different instance of that variable than in the DLL:</p> <pre style="text-indent:0"><br />inline int internal() { static int x; return x++; }<br /><br />struct __declspec(dllimport) S {<br />  int foo() { return internal(); }<br />}<br /></pre> <p>This could lead to very subtle bugs. However, since Chrome already uses -fvisibility-inlines-hidden, which has the same potential problem, we believe this is not a common issue.</p> <h2>Summary</h2> <p>/Zc:dllexportInlines- is like -fvisibility-inlines-hidden for DLLs and significantly reduces build times. We're excited that using Clang on Windows allows us to benefit from new features like this.</p> <h2>More information</h2> <p>For more information, see the <a href="https://clang.llvm.org/docs/UsersManual.html#the-zc-dllexportinlines-option">User's Manual for /Zc:dllexportInlines-</a>.</p> <p>The flag was added in Clang <a href="https://llvm.org/r346069">r346069</a>, which will be part of the Clang 8 release expected in March 2019. It's also available in the <a href="https://llvm.org/builds/">Windows Snapshot Build</a>.</p> <h2>Acknowledgements</h2> <p>/Zc:dllexportInlines- was implemented by Takuto Ikuta based on a prototype by Nico Weber.</p>
