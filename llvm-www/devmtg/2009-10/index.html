<!--#include virtual="../../header.incl" -->

<div class="www_sectiontitle">2009 LLVM Developers' Meeting</div>
<table>
	<tr><td valign="top">
<ol>
	<li><a href="#proceedings">Proceedings</a></li>
	<li><a href="#attendees">Attendees</a></li>
</ol>
</td><td>
<ul>
  <li><b>What</b>: The third general meeting of LLVM Developers and Users.
  </li>
  <li><b>Why</b>: To get acquainted, learn how LLVM is used, and exchange 
  ideas.</li>
  <li><b>When</b>: October 2, 2009</li>
</ul>
</td></tr></table>

<p align="center"><h2><b>SPONSORED BY: <a href="http://apple.com">Apple</a>, <a href="htt
p://google.com">Google</a>, <a href="http://www.adobe.com/">Adobe</a>, <a href="http://ww
w.qualcomm.com/">Qualcomm Incorporated</a></b></h2></p>

<p>The meeting serves as a forum for both <a href="http://llvm.org">LLVM</a>
and <a href="http://clang.llvm.org">Clang</a> developers and users to get acquainted, lea
rn how LLVM is used, and 
exchange ideas about LLVM and its (potential) applications. More broadly, we
believe the event will be of particular interest to the following people:</p>

<ul>
<li>Active LLVM and Clang developers and users.</li>
<li>Anyone interested in using LLVM or Clang.</li>
<li>Compiler, programming language, and runtime enthusiasts.</li>
<li>Those interested in using compiler technology in novel and interesting ways.</li>
</ul>


<div class="www_sectiontitle" id="proceedings">Proceedings</div>

<p>The day was structured to have general overview/introduction talks about some
major LLVM subsystems and talks on applications of LLVM for various
specific projects.</p>

<p>This page lists all of the slides and videos for all of the talks of the 
day.  The talks were held in two rooms - in one room we only were able to 
record a screencast, in the other room we have full video.  The 'mobile' 
versions of the videos are in a generic 'H.264' container, and the 'computer'
versions are in QuickTime format.</p>

<!--<p>In addition to being available here, the videos are also available <a 
href="http://www.youtube.com/view_play_list?p=E05430D58DF9A720">on youtube</a>.</p>
-->
<table class="www">
  <tr><th>Media</th><th>Who</th><th>Description</th></tr>
   
   <tr>
     <td align="center">  
      [<a href="StateOfClang.pdf">Slides</a>]<br>
      [<a href="http://devimages.apple.com/llvm/videos/StateOfClang.mov">Video</a>]    
     </td>    
     <td>Doug Gregor, Chris Lattner, Ted Kremenek<br></td>
     <td>      
        <b>State of Clang</b>
     </td>  
   </tr>
 
  <tr>
    <td align="center">
      [<a href="Korobeynikov_BackendTutorial.pdf">Slides</a>]<p>
      [<a href="Korobeynikov_BackendTutorial-400kbps.mov">Video</a>]&nbsp;<font size="-1">(Computer)</font>
      [<a href="Korobeynikov_BackendTutorial-mobile.m4v">Video</a>]&nbsp;<font size="-1">(Mobile)</font>
    </td>
    <td>Anton Korobeynikov<br><i>Saint Petersburg State University</i></td>
    <td>
      <b>Tutorial: Building backend in 24 hours</b> - A step by step tutorial to
	build a backend.
    </td>
  </tr>
  
  <tr>
    <td align="center">
      [<a href="Geoffray_GarbageCollectionVMKit.pdf">Slides</a>]<p>
      [<a href="https://youtu.be/LcB7V9TcNOQ">Video</a>]
    </td>
    <td>Nicolas Geoffray<br><i>Universite Pierre et Marie Curie</i></td>
    <td><b>Precise and efficient garbage collection in VMKit with MMTk</b> - 
    This talk will describe how we have added precise garbage collection in VMKit, both in the JVM and .Net runtime. The work continues in the spirit of VMKit, in that the garbage collector is an external library provided by others. We have used MMTk, a garbage collector written in Java to provide efficient and precise garbage collection. The talk will give a step by step explanation on how the new system was implemented and provide a tutorial on how this can be adopted by other kinds of VMs implemented with LLVM. Additionally, I will show the new performance results with the new garbage collector. 
    </td>
  </tr>
  
  <tr>
    <td align="center">
      [<a href="Winter_UnladenSwallowLLVM.pdf">Slides</a>]<p>
      [Video]
    </td>
    <td>Colin Winter<br><i>Google</i></td>
    <td><b>Unladen Swallow: Python on LLVM</b> - 
    This talk will go into detail about Unladen Swallow, a Google-sponsored branch of CPython based on LLVM. The talk will describe the architecture of Python-on-LLVM, why we chose LLVM, how we're exploiting LLVM to increase performance, challenges we face in optimizing Python, and future direction for our work.
    </td>
  </tr>
  
  <tr>
    <td align="center">
      [<a href="Sands_LLVMGCCPlugin.pdf">Slides</a>]<p>
      [<a href=""https://youtu.be/EFg7Uj-V1PU>Video</a>]
    </td>
    <td>Duncan Sands<br><i>Deep Blue Capital</i></td>
    <td><b>Reimplementing llvm-gcc as a gcc plugin</b> - 
    Mainline gcc is now able to load additional logic and passes at run-time via a plugin mechanism. It may be possible to replace gcc's optimizers and code generators with those of LLVM via a plugin without needing to modify gcc at all. The goal is to obtain an equivalent of llvm-gcc in this way. I will describe the current status of this project. 
    </td>
  </tr>
 
  <tr>
    <td align="center">
      [<a href="ScalarEvolutionAndLoopOptimization.pdf">Slides</a>]<br>
      [<a href="http://devimages.apple.com/llvm/videos/ScalarEvolutionLoopOptimizationLLVM.mov">Video</a>]
    </td>
    <td>Dan Gohman<br></td>
    <td><b>ScalarEvolution and Loop Optimization</b> - LLVM's ScalarEvolution framework has undergone some major changes and now sports some cool new features. I'll give an overview of what ScalarEvolution can do, illustrate the new features, and discuss the infrastructure behind the functionality.
   </td>
  </tr>
 
  <tr>
    <td align="center">
      [<a href="Lopes_ObjectCodeEmission.pdf">Slides</a>]<p>
      [<a href="https://youtu.be/VPyZBi39Ymw">Video</a>]
    </td>
    <td>Bruno Cardoso Lopes<br><i>University of Campinas</i></td>
    <td><b>Object Code Emission and llvm-mc</b> - 
    A high level overview of the LLVM Machine Code Emitter, with a specific focus on the emission of object files: the design and current implementation status.
    </td>
  </tr>
  
  <tr>
    <td align="center">
      [<a href="Greene_180k_Cores.pdf">Slides</a>]<p>
      [<a href="Greene_180k_Cores-400kbps.mov">Video</a>]&nbsp;<font size="-1">(Computer)</font>
      [<a href="Greene_180k_Cores-mobile.m4v">Video</a>]&nbsp;<font size="-1">(Mobile)</font>
    </td>
    <td>David Greene<br><i>Cray</i></td>
    <td><b>LLVM on 180k Cores</b> - 
    	In this talk we'll see how Cray incorporated LLVM into an existing highly optimizing, vectorizing and parallelizing compiler. Attendees will learn about the pitfalls encountered as well as the benefits of using an Open Source codegen solution. We will also discuss various modifications to LLVM that Cray is currently in the process of integrating back into the community repository.
    </td>
  </tr>
  
  <tr>
    <td align="center">
      [<a href="Cifuentes_ParfaitBugChecker.pdf">Slides</a>]<p>
      [<a href="https://youtu.be/a9v_KR4bdiU">Video</a>]
    </td>
    <td>Cristina Cifuentes<br><i>Sun Microsystems</i></td>
    <td><b>The Parfait Bug-Checker</b> - 
    Parfait is a research bug-checking project for C built on top of LLVM. Parfait is being used internally within Sun to find bugs in various applications including the Solaris(TM) operating system. Externally, Parfait is being tested in the OS community with the OpenBSD, Linux and FreeBSD kernels. In this talk we explain Parfait's design for scalability and precision, explain some of the internals of the tool and how it is built on top of LLVM, and give a demo against open source code bases.
    </td>
  </tr>
  
  <tr>
    <td align="center">
      [<a href="Petersen_OptimizingActionScriptBytecode.pdf">Slides</a>]<p>
      [<a href="Petersen_OptimizingActionScriptBytecode-400kbps.mov">Video</a>]&nbsp;<font size="-1">(Computer)</font>
      [<a href="Petersen_OptimizingActionScriptBytecode-mobile.m4v">Video</a>]&nbsp;<font size="-1">(Mobile)</font>
    </td>
    <td>Scott Petersen<br><i>Adobe Systems, Inc.</i></td>
    <td><b>Optimizing ActionScript Bytecode using LLVM</b> - 
    LLVM has state-of-the-art optimization capabilities that can operate against LLVM bitcode. But many of these optimizations are not intrinsically specific to LLVM's representation of programs. Adobe has built a proof-of-concept implementation of an ActionScript Bytecode optimizer using LLVM. This talk will discuss the implementation of the optimizer and possible future directions for this type of technology.
    </td>
  </tr>
  
  <tr>
    <td align="center">
      [<a href="Osborne_TargetingXCoreResources.pdf">Slides</a>]<p>
      [<a href="https://youtu.be/DF-2gA_0QfU">Video</a>]
    </td>
    <td>Richard Osborne<br><i>XMOS</i></td>
    <td><b>Targeting XCore resources from LLVM</b> -  
    The XCore is an event driven multi-threaded processor. It provides direct hardware support for interprocess communication using channels and precise timing of inputs and outputs on I/O pins using ports. This talks looks at using LLVM to compile an version of C extended with support for explicit parallelism and I/O to the XCore.
    </td>
  </tr>

  <tr>
    <td align="center">
      [<a href="RegisterAllocationFutureWorks.pdf">Slides</a>]<br>
      [<a href="http://devimages.apple.com/llvm/videos/FutureLLVMRegister.mov">Video</a>]<br>
    </td>
    <td>Lang Hames<br></td>
    <td><b>Future Works in LLVM Register Allocation</b> - About the future of register allocation in LLVM.
    </td>
  </tr>
 
  <tr>
    <td align="center">
      [<a href="Zaks_CoVaC.pdf">Slides</a>]<p>
      [<a href="https://youtu.be/iXTliWhYpRs">Video</a>]
    </td>
    <td>Anna Zaks<br><i>New York University</i></td>
    <td><b>CoVaC: Compiler Validation by Program Analysis of the Cross-Product</b> -  
    CoVaC is a framework for formal verification of the compiler optimization phase. This talk gives a brief overview of the prototype tool, which has been developed on top of LLVM 2.0. The CoVaC framework checks that optimization passes preserve semantics of the program being compiled by proving that the unoptimized program is equivalent to the optimized one. To leverage existing program analysis techniques, we reduce the equivalence checking problem to analysis of one system - a cross-product of the two input programs. 
The talk is based on the following paper: Compiler Validation by Program Analysis of the Cross-Product, Anna Zaks and Amir Pnueli, FM'08
    </td>
  </tr>

  <tr>
    <td align="center">
      [<a href="OpenCLWithLLVM.pdf">Slides</a>]<br>
      [<a href="http://devimages.apple.com/llvm/videos/OpenCLandLLVM.mov">Video</a>]<br>
    </td>
    <td>Nate Begeman<br></td>
    <td><b>OpenCL</b></td>
  </tr> 
 
  <tr>
    <td align="center">
      [<a href="Nagarakatte_SoftBound.pdf">Slides</a>]
      [<a href="Nagarakatte_SoftBound.pptm">Slides</a>]&nbsp;<font size="-1">(.ppt)</font><p>
      [<a href="https://youtu.be/0nNGS8D5xDg">Video</a>]
    </td>
    <td>Santosh Nagarakatte<br><i>University of Pennsylvania</i></td>
    <td><b>SoftBound: Highly Compatible and Complete Spatial Memory Safety for C</b> - 
SoftBound is a compile-time transformation for enforcing spatial safety of C. SoftBound records base and bound information for every pointer as disjoint metadata. This decoupling enables SoftBound to provide spatial safety without requiring changes to C source code. SoftBound is a software-only approach and performs metadata manipulation only when loading or storing pointer values. This talk provides a brief description of the formal proof and llvm implementation. 
    </td>
  </tr>

  <tr>
    <td align="center">
      [<a href="Grover_PLANG.pdf">Slides</a>]
      [<a href="Grover_PLANG-400kbps.mov">Video</a>]&nbsp;<font size="-1">(Computer)</font>
      [<a href="Grover_PLANG-mobile.m4v">Video</a>]&nbsp;<font size="-1">(Mobile)</font>
    </td>
    <td>Vinod Grover<br><i>NVIDIA</i></td>
    <td><b>PLANG: Translating NVIDIA PTX language to LLVM IR
        Machine</b> - 
    	PTX is an abstract ISA, for NVIDIA GPUs, targeted by CUDA and several other tools. PTX is jitted or compiled to a supported GPU for execution. We describe PLANG, a new front-end for PTX that emits LLVM and leverages its analysis, transformation and code generation infrastructure for PTX. Based on PLANG we have built several analysis and translation tools for PTX, e.g. synchronization analysis, visualization and targeting execution of PTX on x86 processors. In this talk we will describe PLANG, and our experiences in building tools based on LLVM.
    </td>
  </tr>

  <tr>
    <td align="center">
      [<a href="Phoenix_AcceleratingRuby.pdf">Slides</a>]
      [<a href="https://youtu.be/J8Q1ljBMFjA">Video</a>]
    </td>
    <td>Evan Phoenix<br><i>Engine Yard</i></td>
    <td><b>Accelerating Ruby with LLVM 
        </b> -  
    Rubinius is a ruby VM that strives to write as much of the system in ruby itself as it can. To make this practical, we're using LLVM to JIT frequently used methods. I'll cover briefly the architecture of Rubinius, spending most of the time discussing the integration points. These include: Background compilation, runtime profile guide optimization, efficient IR generation, etc.
	</td>
  </tr>
</table>  

<div class="www_sectiontitle"><a name="attendees">Attendees</a></div>
<div class="www_text">
<p>We had approximately 170 attendees with a huge range of different 
affiliations.
</p>

</div>

<!-- *********************************************************************** -->
<hr>

<!--#include virtual="../../footer.incl" -->
